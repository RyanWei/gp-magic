#!/usr/bin/perl
use strict;
use Switch;
use threads;
use Thread::Queue;
use Getopt::Long qw(:config bundling no_ignore_case no_autoabbrev);
use POSIX;

my ($BATCH_MAX,$BATCH_DEFAULT,$BATCH_MIN)=(32,5,1);

my $BACKUP_TASK_QUEUE;
my $BACKUP_MSGE_QUEUE;

my $HELP_MESSAGE=qq{COMMAND NAME: backup
Backup a Greenplum database data to compress files one file by one table on all segment instance.
************************************************************************************************
SYNOPSIS
************************************************************************************************
backup -d database_name [--FG date_flag] [-t table_name [-t tables_name] ...] [-f tables_name_file] [-b tables_table_name]
    [-s schema_name [-s schema_name] ...] [-B batch_size] [--WHERE where_condition ] [-a] [--TC] [-h|--help]
*****************************************************
DESCRIPTION
*****************************************************
The backup utility is used to backup the Greenplum Database User's data.
When you start backup,the utility will backup every table to local disk.

Backup is running in parallel.
One table's backup is running at once on all Segment Instance.
At any time,there are several tables are backup.
*****************************************************
OPTIONS
*****************************************************

-d <backup Database name>

  Backup table in this database
  eg.:
  -d postgres

--FG <date_FlaG>

  Backup date flag.
  eg.:
  --FG 20160101

-t <backup Table name>

  Backup table with this name
  eg.:
  -t schema.tablename

-f <File name>

  Backup table list in this file name
  eg.:
  schema.tablename;(where) condition
  OR
  schema.tablename

-b <taBle name>

  database.schema.table
  Backup table list in this database table
  eg.:
  schema.tablename;(where) condition
  OR
  schema.tablename

-s <Schema_name>

  Backup tables in this schema
  eg.:
  public

-B <Batch size>

  Backup tables number at once.
  Default is $BATCH_DEFAULT.
  Max is $BATCH_MAX.
  Min is $BATCH_MIN.

--WHERE <WHERE condition>

  With condition when dump a table.
  eg.:
  --WHERE "data_date='2016-01-01'"

-a

  Backup only data, no ddls will be backup.

--TC

  Truncate table data after success backup table data.

example:
backup -d postgres --FG 20160120 -B 4 -a
backup -d postgres -B 4
backup -h | --help
};
sub prt_msg{
    my ($flag,$msg)=@_;
    my $time_flag=substr(`date +%Y%m%d:%H:%M:%S.%N`,0,-3);
    my $prtstr="$time_flag-[$flag]-:$msg\n";
    print $prtstr;
    return $prtstr;
}
sub err_msg{
    my ($msg)=@_;
    prt_msg("ERROR",$msg);
    print "Usage: backup [-h|--help] [options]\n";
    exit 1;
}
sub log_msg{
    my ($file_path,$flag,$msg)=@_;
    my $prtmsg=prt_msg($flag,$msg);
    if(!open(FILE,">>",$file_path)){
        err_msg("Can't open file: $file_path");
    }
    print FILE $prtmsg;
    close FILE;
}
sub log_dof{
    my ($file_path,$tb_nam)=@_;
    if(!open(FILE,">>",$file_path)){
        err_msg("Can't open file: $file_path");
    }
    print FILE $tb_nam."\n";
    close FILE;
}
sub trim{
    my ($str)=@_;
    $str=~s/(^\s+|\s+$)//g;
    return $str;
}
sub read_file{
    my ($file_path)=@_;
    if(!-e $file_path){
        err_msg("No file exists named: $file_path");
    }
    if(!open(FILE,"<",$file_path)){
        err_msg("Can't open file: $file_path");
    }
    my @array=();
    while(my $line=<FILE>){
        $line=trim($line);
        if(!($line=~/^#/) && "" ne $line){
            my ($rel_nm,$wr_cdt)=split(/;/,$line);
            push @array,[($rel_nm,$wr_cdt)];
        }
    }
    close FILE;
    return @array;
}
sub query_result{
    my ($db_nam,$qr_sql,$er_msg,$rt_flg)=@_;
    my $qr_rst=readpipe(qq{psql -v ON_ERROR_STOP=1 -tAXF '#!^' -d $db_nam 2>&1 <<END_OF_SQL
$qr_sql
END_OF_SQL});
    my $rt_cod=$?>>8;
    if("CV" eq $rt_flg){
        return ($rt_cod,$qr_rst);
    }
    if($?){
        if("" ne $er_msg){
            err_msg($er_msg);
        }
        err_msg($qr_rst);
    }elsif("Scalar" eq $rt_flg){
        return trim($qr_rst);
    }else{
        my @rw_ary=split(/\n/,$qr_rst);
        my @rt_set=();
        for my $row(@rw_ary){
            push @rt_set,[split(/#\!\^/,$row)];
        }
        return @rt_set;
    }
}
sub check_table_exists{
    my ($db_nam,$sc_nam,$rl_nam)=@_;
    my $ck_sql="select 1 from pg_catalog.pg_class c,pg_catalog.pg_namespace n where c.relnamespace=n.oid and n.nspname='$sc_nam' and c.relname='$rl_nam'";
    my $ck_rst=query_result($db_nam,$ck_sql,"","Scalar");
    if("" eq $ck_rst){
        err_msg("Table not exists named: $sc_nam.$rl_nam in database $db_nam");
    }
    return;
}
sub query_tables{
    my ($db_nam,$sc_nam,$rl_nam)=split(/(?!\\\\)\./,$_[0]);
    check_table_exists($db_nam,$sc_nam,$rl_nam);
    my @tb_ary=();
    my @result=query_result($db_nam,qq{select * from "$sc_nam"."$rl_nam"});
    for my $row(@result){
        my ($tb_nam,$wr_cdt)=@$row;
        push @tb_ary,[($tb_nam,$wr_cdt)];
    }
    return @tb_ary;
}
##(sc_nam,rl_nam)
sub query_backup_default{
    my ($db_nam)=@_;
    my $tb_sql="select n.nspname,c.relname from pg_class c,pg_namespace n,gp_distribution_policy p
    where c.relnamespace=n.oid and c.oid=p.localoid and (c.relnamespace>16384 or n.nspname='public') and n.nspname not like E'pg\\_temp\\_%'
    and c.relkind='r' and relstorage<>'x' and c.oid not in(select parchildrelid from pg_partition_rule);";
    return query_result($db_nam,$tb_sql);
}
sub check_random_table{
    my ($ms_lgf,$db_nam)=@_;
    my $ck_def_sql=qq{select 5 from pg_class where relname='gp_segment_config' and relnamespace=(select oid from pg_namespace where nspname='gp_toolkit')};
    my $ck_def_rst=query_result($db_nam,$ck_def_sql,"","Scalar");
    if("" eq $ck_def_rst){
        log_msg($ms_lgf,"INFO","No table gp_toolkit.gp_segment_config, create it");
	query_result($db_nam,qq{create table gp_toolkit.gp_segment_config(db_cnt int,db_pth varchar(128),db_pot int)distributed randomly;});
    }
    my $ck_rcd_sql=qq{select (select count(*) from gp_dist_random('gp_id')) seg_nbr,
            count(*) all_nbr, count(*) filter(where sc.db_cnt is null) noe_nbr,
            count(*) filter(where sc.db_cnt<>sc.gp_segment_id) err_nbr
        from (select c.content,f.fselocation,c.port,c.hostname from gp_segment_configuration c,pg_filespace_entry f
            where c.dbid=f.fsedbid and c.status='u' and c.role='p' and c.content>=0 and f.fsefsoid=(select oid from pg_filespace where fsname='pg_system')
        ) md left join gp_toolkit.gp_segment_config sc
        on md.content=sc.db_cnt and md.fselocation=sc.db_pth and md.port=sc.db_pot;
    };
    my @ck_rcd_rst=query_result($db_nam,$ck_rcd_sql);
    my ($seg_nbr,$all_nbr,$noe_nbr,$err_nbr)=@{$ck_rcd_rst[0]};
    if($seg_nbr ne $all_nbr || $noe_nbr ne 0 || $err_nbr ne 0){
        log_msg($ms_lgf,"INFO","Racord in gp_toolkit.gp_segment_config incorrect, re insert");
        query_result($db_nam,"truncate table gp_toolkit.gp_segment_config");
	my $ist_qry="select c.content,f.fselocation,c.port,c.hostname from gp_segment_configuration c, pg_filespace_entry f 
	    where c.dbid=f.fsedbid and c.status='u' and c.role='p' and c.content>=0 and f.fsefsoid=(select oid from pg_filespace where fsname='pg_system')";
	my @ist_rst=query_result($db_nam,$ist_qry);
	foreach my $ist_row(@ist_rst){
            my ($ist_ctnt,$ist_drct,$ist_port,$ist_hsnm)=@$ist_row;
            my $OPTS="PGOPTIONS='-c gp_session_role=utility' psql -tAX -d $db_nam -h $ist_hsnm -p $ist_port ";
	    my $ist_shell=qq{$OPTS -c "insert into gp_toolkit.gp_segment_config values($ist_ctnt,'$ist_drct',$ist_port)" >/dev/null 2>&1};
	    system($ist_shell);
	}
    }
    return;
}
sub check_backup_function{
    my ($ms_lgf,$db_nam)=@_;
    my $lang_sql=qq{select 5 from pg_language where lanname = 'plpythonu'};
    my $lang_rst=query_result($db_nam,$lang_sql,"","Scalar");
    if("" eq $lang_rst){
        log_msg($ms_lgf,"NOTICE","No language plpythonu exists in database, create it");
        query_result($db_nam,"create language plpythonu");
    }
    my $md5_sql="select md5(prosrc) from pg_proc where proname='gp_backup_function' and pronamespace=(select oid from pg_namespace where nspname='gp_toolkit')";
    my $md5_rst=query_result($db_nam,$md5_sql,"","Scalar");
    if("9fc455a0a90023fe358b87b8feae7617" ne $md5_rst){
        log_msg($ms_lgf,"NOTICE","No backup function or need replace, create or replace it");
        my $fc_sql=q{
create or replace function gp_toolkit.gp_backup_function(db_nam varchar,db_pot int,db_cnt int,db_pth varchar,tb_nam varchar,dt_flg varchar,wr_cdt varchar)returns integer as \$\$
import commands
try:
    cmd=""
    bk_pth="%s/db_dumps/%s" % (db_pth,dt_flg)
    bk_fil="%s^%s^%s" % (db_nam,db_cnt,tb_nam)
    wr_sql=""
    if ""!=wr_cdt:
        wr_sql=" where %s" % (wr_cdt)
    (scm,rel)=tb_nam.split(".")
    cmd="""\`source /usr/local/greenplum-db/greenplum_path.sh;export PGOPTIONS='-c gp_session_role=utility'
mkdir -p %s
psql -X -v ON_ERROR_STOP=1 -d %s -p %s <<EOF|gzip > %s/%s.gz
copy (select * from "%s"."%s"%s) to STDOUT
EOF
\`""" % (bk_pth,db_nam,db_pot,bk_pth,bk_fil,scm,rel,wr_sql)
    (rcod,rvlu)=commands.getstatusoutput(cmd)
    if len(rvlu)>0:
        plpy.error(rvlu)
    elif rcod!=0:
        plpy.error("Unknown error with code: %s" % (rcod))
    else:
        return 0
except Exception, e:
    plpy.error(str(e))
\$\$ language plpythonu;};
        query_result($db_nam,$fc_sql);
    }
    return;
}
sub get_master_path{
    my ($db_nam)=@_;
    my $pt_sql="select f.fselocation from gp_segment_configuration c, pg_filespace_entry f
        where c.dbid=f.fsedbid and c.status='u' and c.role='p' and c.content=-1 and f.fsefsoid=(select oid from pg_filespace where fsname='pg_system');";
    return query_result($db_nam,$pt_sql,"","Scalar");
}
sub parse_parameter{
    my ($ms_lgf,$db_nam,$tb_ary_,$tb_fil,$ms_dof,$tb_tab,$sc_ary_,$bt_siz,$wr_cdt,$dt_flg,$dt_oly,$nd_trc)=@_;
    ##get table list all in the database
    my @all_table_array=query_backup_default($db_nam);
    ##tables input from command parameter
    my @slf_table_array=();
    ##user defined flag
    my $sf_flg=0;
    ##user defined tables hashmap
    my %slf_hash=();
    for my $sc_nam(@$sc_ary_){
        $sf_flg=1;
        my @sc_tab=grep({$_->[0] eq $sc_nam}@all_table_array);
        my $sc_siz=@sc_tab;
        if($sc_siz==0){
            log_msg($ms_lgf,"WARNING","Schema not exists or no table in schema named: $sc_nam");next;
        }
        for my $row(@sc_tab){
            my ($sc_nam,$rl_nam)=@$row;
            my $tb_nam=$sc_nam.".".$rl_nam;
            $slf_hash{$tb_nam}="";
        }
    }
    if("" ne $tb_fil){$sf_flg=1;push @slf_table_array,read_file($tb_fil);}
    if("" ne $tb_tab){$sf_flg=1;push @slf_table_array,query_tables($tb_tab);}
    ##all table in database, hashmap
    my %dft_hash=();
    for my $row(@all_table_array){
        my ($sc_nam,$rl_nam)=@$row;
        my $tb_nam=$sc_nam.".".$rl_nam;
        $dft_hash{$tb_nam}="";
    }
    for my $row(@slf_table_array){
        my ($tb_nam,$wr_cdt)=@$row;
        if(!exists $dft_hash{$tb_nam}){
            log_msg($ms_lgf,"WARNING","Table name from file or table not exists: $tb_nam");
        }elsif(exists $slf_hash{$tb_nam}){
            log_msg($ms_lgf,"NOTICE","Table name from file or table duplicate: $tb_nam");
        }else{
            $slf_hash{$tb_nam}=$wr_cdt;
        }
    }
    for my $tb_nam(@$tb_ary_){
        $sf_flg=1;
        if(!exists $dft_hash{$tb_nam}){
            log_msg($ms_lgf,"WARNING","Table name from command line not exists: $tb_nam");
        }elsif(exists $slf_hash{$tb_nam}){
            log_msg($ms_lgf,"NOTICE","Table name from command line duplicate: $tb_nam");
        }else{
            $slf_hash{$tb_nam}="";
        }
    }
    my %done_hash={};
    if(-e $ms_dof){
        log_msg($ms_lgf,"NOTICE","Find backup done file: $ms_dof");
        my @done_array=read_file($ms_dof);
        for my $row(@done_array){
            my ($tb_nam)=@$row;
            $done_hash{$tb_nam}="";
        }
    }else{
        log_msg($ms_lgf,"NOTICE","Backup done file created: $ms_dof");
    }
    my @bk_tab=();
    if($sf_flg){
        my @keys=keys %slf_hash;
        log_msg($ms_lgf,"INFO","Backup user defined table list");
        for my $tb_nam(@keys){
            if(!exists $done_hash{$tb_nam}){
                push @bk_tab,[($tb_nam,$slf_hash{$tb_nam})];
            }
        }
    }else{
        log_msg($ms_lgf,"INFO","Backup all user table in database: $db_nam");
        for my $row(@all_table_array){
            my ($sc_nam,$rl_nam)=@$row;
            my $tb_nam=$sc_nam.".".$rl_nam;
            if(!exists $done_hash{$tb_nam}){
                push @bk_tab,[($tb_nam,"")];
            }
        }
    }
    my $size=@bk_tab;
    if(0==$size){log_msg($ms_lgf,"WARNING","No table will be backup");exit 0;}
    return @bk_tab;
}
sub execute_thread{
    my ($dt_flg,$db_nam,$g_wr_cdt,$nd_trc)=@_;
    my $bk_tsk=$BACKUP_TASK_QUEUE->dequeue();
    while(defined $bk_tsk){
        #(tb_nam,wr_cdt)
        my ($tb_nam,$wr_cdt)=@$bk_tsk;
        #just for message
        my ($bk_fil)=("db_dumps/$dt_flg/$db_nam^cnt^$tb_nam.gz");
        #check condition
        if("" eq $wr_cdt){$wr_cdt=$g_wr_cdt;}
        $wr_cdt=~s/'/''/g;
        my @rt_msg :shared;
            #parallel dump table data
        my $bk_sql=qq{select sum(gp_toolkit.gp_backup_function('$db_nam',db_pot,db_cnt,db_pth,'$tb_nam','$dt_flg','$wr_cdt')) from gp_toolkit.gp_segment_config;};
        my ($bk_cod,$bk_rst)=query_result($db_nam,$bk_sql,"","CV");
        #process message
        if($bk_cod eq 0){
            @rt_msg=("0","BACKUP SUCCESS: $bk_fil",$tb_nam);
            if($nd_trc){
                my($scm,$rel)=split(/\./,$tb_nam);
                query_result($db_nam,qq{truncate table "$scm"."$rel";},"","CV");
            }
        }else{
            @rt_msg=("1","BACKUP ERROR: $bk_fil ".$bk_rst,$tb_nam);
        }
        $BACKUP_MSGE_QUEUE->enqueue(\@rt_msg);
        $bk_tsk=$BACKUP_TASK_QUEUE->dequeue();
    }
    my @rt_msg :shared=("0",undef);
    $BACKUP_MSGE_QUEUE->enqueue(\@rt_msg);
    return;
}
sub message_thread{
    my ($ms_lgf,$ms_dof,$tb_siz,$bt_siz)=@_;
    my $ed_idx=0;
    my $ss_idx=0;
    my $al_idx=0;
    my ($rt_cod,$rt_msg,$tb_nam)=@{$BACKUP_MSGE_QUEUE->dequeue()};
    while(1){
        if(defined $rt_msg){
            $al_idx+=1;
            if("1" eq $rt_cod){
                log_msg($ms_lgf,"WARNING","($al_idx/$tb_siz)".$rt_msg);
            }else{
                $ss_idx+=1;
                log_msg($ms_lgf,"INFO","($al_idx/$tb_siz)".$rt_msg);
                log_dof($ms_dof,$tb_nam);
            }
        }else{
            $ed_idx+=1;
            if($ed_idx eq $bt_siz){
                last;
            }
        }
        ($rt_cod,$rt_msg,$tb_nam)=@{$BACKUP_MSGE_QUEUE->dequeue()};
    }
    if($ss_idx!=$tb_siz){
        log_msg($ms_lgf,"INFO","Finish data backup with error $ss_idx/$tb_siz ......");
    }else{
        log_msg($ms_lgf,"INFO","Finish data backup with all success $ss_idx/$tb_siz......");
    }
}
sub main{
    system("unset PGOPTIONS");
    ##define tables array, to store tables name defined by user parameter
    my @tb_ary=();
    my @sc_ary=();
    ##get all user parameter
    my ($db_nam,$tb_fil,$tb_tab,$bt_siz,$wr_cdt,$dt_flg,$dt_oly,$nd_trc,$hp_msg);
    GetOptions(
        'd=s'     =>    \$db_nam,
        't:s'     =>    \@tb_ary,
        'f:s'     =>    \$tb_fil,
        'b:s'     =>    \$tb_tab,
        's:s'     =>    \@sc_ary,
        'B:i'     =>    \$bt_siz,
        'WHERE:s' =>    \$wr_cdt,
        'FG:i'    =>    \$dt_flg,
        'a!'      =>    \$dt_oly,
        'TC!'     =>    \$nd_trc,
        'h|help!' =>    \$hp_msg,
    );
    ##process date flag
    my $td_flg=strftime("%Y%m%d",localtime);
    if("" eq $dt_flg){
        $dt_flg=$td_flg;
    }
    if($hp_msg){print $HELP_MESSAGE;exit 0;}
    if("" eq $db_nam){err_msg("No database name supplied");}
    ##process log info
    my $ms_pth=get_master_path($db_nam);
    my $ms_lgp="$ms_pth/db_dumps/$dt_flg";
    system("mkdir -p $ms_lgp");
    my $ms_lgf="$ms_lgp/backup_log.txt";
    my $ms_dof="$ms_lgp/backup_done.txt";
    log_msg($ms_lgf,"INFO","Start backup".("." x 66));
    log_msg($ms_lgf,"INFO","Run command: ".$_[0]);
    ##process parameter
    my @bk_tab=parse_parameter($ms_lgf,$db_nam,\@tb_ary,$tb_fil,$ms_dof,$tb_tab,\@sc_ary,$bt_siz,$wr_cdt,$dt_flg,$dt_oly,$nd_trc);
    my $bk_siz=@bk_tab;
    check_random_table($ms_lgf,$db_nam);
    check_backup_function($ms_lgf,$db_nam);
    ##init queue
    $BACKUP_TASK_QUEUE=Thread::Queue->new();
    $BACKUP_MSGE_QUEUE=Thread::Queue->new();
    for my $tsk(@bk_tab){
        my @tsk_ary :shared=@$tsk;
        $BACKUP_TASK_QUEUE->enqueue(\@tsk_ary);
    }
    ##start backup
    log_msg($ms_lgf,"INFO","Start backup process ......");
    log_msg($ms_lgf,"INFO","Backup directory is $ms_pth/db_dumps/$dt_flg");
    ##backup ddls pre
    if(!$dt_oly){
        log_msg($ms_lgf,"INFO","Backup DDLs and OBJECTs and AUTHORIZATIONs");
        system("pg_dumpall -g -f $ms_pth/db_dumps/$dt_flg/$db_nam.global.txt");
        system("pg_dump -s -f $ms_pth/db_dumps/$dt_flg/$db_nam.ddl.txt $db_nam");
    }
    ##process batch size
    if(!defined($bt_siz) || $bt_siz>$BATCH_MAX || $bt_siz<$BATCH_MIN){
        $bt_siz=$BATCH_DEFAULT;
    }
    log_msg($ms_lgf,"INFO","Number of tables should be backed is: $bk_siz");
    log_msg($ms_lgf,"INFO","Use batch size as $bt_siz");
    ##start batch thread
    my @thrd_array=();
    for my $idx(1..$bt_siz){
        $BACKUP_TASK_QUEUE->enqueue(undef);
        my $tsk_thrd=threads->new(\&execute_thread,$dt_flg,$db_nam,$wr_cdt,$nd_trc);
        push @thrd_array,$tsk_thrd;
    }
    ##start message thread
    my $msg_thrd=threads->new(\&message_thread,$ms_lgf,$ms_dof,$bk_siz,$bt_siz);
    push @thrd_array,$msg_thrd;
    for my $thrd(@thrd_array){
        $thrd->join();
    }
    ##end backup
}
my $cm_str=$0." ".join(" ",@ARGV);
main($cm_str);
